---
title: "ETC1010: Data Modelling and Computing"
subtitle: 'Lecture 5: Reading different data formats'
author: "Di Cook (dicook@monash.edu, @visnut)"
date: "Week 5"
output:
  xaringan::moon_reader:
    css: ["default", "myremark.css"]
    self_contained: false
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---

```{r, echo = FALSE, warning = FALSE, message=FALSE}
knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE,
  collapse = TRUE,
  echo=FALSE,
  comment = "",
  fig.height = 6,
  fig.width = 10,
  fig.align = "center",
  cache = FALSE
)
library(tidyverse)
library(gridExtra)
library(plotly)
library(ggthemes)
library(ggmap)
library(lubridate)
library(haven)
library(readxl)
```

# Overview

- Shape files for maps
- Excel spreadsheets
- Googlesheets
- SPSS format (PISA data)
- Audio files
- `read_csv` vs `read.csv`
- feather for large binary files
- Handling large data sets by constructing a small database: `sqlite`
- Web format (json) data, `jsonlite` (crossrates)
- Web scraping?

---
# Shape files

Download the Australian electorate shape files from [http://www.aec.gov.au/Electorates/gis/gis_datadownload.htm], 2016 national, mapinfo format. Its 11Mb.

```{r}
library(eechidna)
library(rgdal)
sF <- readOGR(dsn="data/national-midmif-09052016/COM_ELB.TAB", layer="COM_ELB")
glimpse(sF)
```

---
class: inverse middle 
# Your turn

How many Federal electorates in Australia?

---
# Thinning out space

- The shape object created is 46Mb. Too big!
- Want smaller data set, that still effectively describes the spatial domain.
- Thinning a map object can be tricky, want to thin long straight areas but keep twisty boundaries detailed. 

```{r echo=TRUE}
library(rmapshaper)
sFsmall <- ms_simplify(sF, keep=0.05)
```

---
# Plot it

```{r}
plot(sFsmall)
```

Map is still defined in shapefile structure. Difficult to work with, in conjunction with any other data.

---
# Extract information on each electorate

```{r echo=TRUE}
nat_data <- sF@data
nat_data$id <- row.names(nat_data)
head(nat_data)
```

---
# Get map into tidy form

```{r echo=TRUE}
nat_map <- ggplot2::fortify(sFsmall)
head(nat_map)
```

---
# Be clear about id variables

- Ensure group and piece variables are treated as factors, not numbers
- Add electorate names to the polygons

```{r echo=TRUE}
nat_map$group <- paste("g",nat_map$group,sep=".")
nat_map$piece <- paste("p",nat_map$piece,sep=".")
nms <- sFsmall@data %>% select(Elect_div, State)
nms$id <- as.character(1:150)
nat_map <- left_join(nat_map, nms, by="id")
head(nat_map)
```

---
# 

Map it, using area of the electorate to colour. With joins to data from other sources, e.g. census, other variables could be mapped to colour. 

```{r echo=TRUE}
ggplot(aes(map_id=id), data=nat_data) +
  geom_map(aes(fill=Area_SqKm), map=nat_map) +
  expand_limits(x=nat_map$long, y=nat_map$lat) + 
  theme_map()
```

---
# Interactivity

Mouseover names more effective 

```{r echo=TRUE, eval=FALSE}
p <- ggplot(aes(map_id=id), data=nat_data) +
  geom_map(aes(fill=Area_SqKm, label=Elect_div), map=nat_map) +
  expand_limits(x=nat_map$long, y=nat_map$lat) + 
  theme_map()
ggplotly(p)
```


---
# Add centroids

Using the geographic centroid for each electorate is an alternative. It can also be extracted from the shape files.


```{r results='hide'}
class(sF)
polys <- as(sF, "SpatialPolygons")
class(polys) # should be SpatialPolygons
length(polys) # should be 150
slotNames(polys)
Polygon(polys[1])
```

```{r echo=TRUE}
centroid <- function(i, polys) {
  ctr <- Polygon(polys[i])@labpt
  data.frame(long_c=ctr[1], lat_c=ctr[2])
}
centroids <- seq_along(polys) %>% purrr::map_df(centroid, polys=polys)
head(centroids)
```

---

joined to the other information about each electorate...


```{r echo=TRUE}
nat_data <- bind_cols(nat_data, centroids)
head(nat_data)
```

---

and plotted as is, or spread out

```{r echo=TRUE, fig.width=12, fig.height=5}
p1 <- ggplot(aes(map_id=id), data=nat_data) +
  geom_map(aes(fill=Area_SqKm), map=nat_map) +
  expand_limits(x=nat_map$long, y=nat_map$lat) + 
  theme_map() + theme(legend.position="none") +
  geom_point(data=nat_data, aes(x=long_c, y=lat_c), colour="orange")
p2 <- ggplot(aes(map_id=id), data=nat_data) +
  geom_map(aes(fill=Area_SqKm), map=nat_map) +
  expand_limits(x=nat_map$long, y=nat_map$lat) + 
  theme_map() + theme(legend.position="none") +
  geom_jitter(data=nat_data, aes(x=long_c, y=lat_c),
              colour="orange", width=2, height=2)
grid.arrange(p1, p2, ncol=2)
```

---
# Excel spreadsheets

- Often data comes in multiple excel format files
- It it tedious, and inefficient to manually convert each to csv and read
- Easier to automate reading multiple files, in the original format
- Example: Rental market in Tasmania from [data.gov.au](http://data.gov.au/dataset/rental-bond-and-rental-data-tasmania-2016-to-2017)

---

```{r echo=TRUE}
library(readxl)
library(sawfish) # devtools::install_github("AnthonyEbert/sawfish")
url<-"http://data.gov.au/dataset/rental-bond-and-rental-data-tasmania-2016-to-2017"
fls <- find_files(url, "xlsx")
f1 <- tempfile()
download.file(fls[1], f1, mode="wb")
t1 <- read_xlsx(path=f1, sheet=1)
t1
```

---
# Now pull all and merge

```{r cache=TRUE, echo=TRUE}
rentals <- NULL
for (i in 1:length(fls)) {
  download.file(fls[i], f1, mode="wb")
  t1 <- read_xlsx(path=f1, sheet=1)
  rentals <- bind_rows(rentals, t1)
}
dim(rentals)
```

---
# How have rental rates changed over time

```{r echo=TRUE, fig.show='hide'}
rentals %>% 
  mutate(month=month(`Bond Lodgement date (DD/MM/YYYY)`), 
         year=year(`Bond Lodgement date (DD/MM/YYYY)`)) %>%
  group_by(Postcode, month, year, `No of Bedrooms`) %>%
  summarise(rent=mean(`Weekly Rent`, na.rm=TRUE)) %>%
  mutate(time=dmy(paste("01", month, year, sep="-"))) %>%
  ggplot(aes(x=time, y=rent)) +
    geom_line(aes(group=Postcode)) +
    facet_wrap(~`No of Bedrooms`, ncol = 3) +
    ylab("Weekly rent")
```

---

```{r}
rentals %>% 
  mutate(month=month(`Bond Lodgement date (DD/MM/YYYY)`), 
         year=year(`Bond Lodgement date (DD/MM/YYYY)`)) %>%
  group_by(Postcode, month, year, `No of Bedrooms`) %>%
  summarise(rent=mean(`Weekly Rent`, na.rm=TRUE)) %>%
  mutate(time=dmy(paste("01", month, year, sep="-"))) %>%
  ggplot(aes(x=time, y=rent)) +
    geom_line(aes(group=Postcode)) +
    facet_wrap(~`No of Bedrooms`, ncol = 3) +
    ylab("Weekly rent")
```

---
# Clean data and re-plot

```{r echo=TRUE, fig.show='hide'}
rentals %>% 
  mutate(month=month(`Bond Lodgement date (DD/MM/YYYY)`), 
         year=year(`Bond Lodgement date (DD/MM/YYYY)`)) %>%
  group_by(Postcode, month, year, `No of Bedrooms`) %>%
  summarise(rent=mean(`Weekly Rent`, na.rm=TRUE)) %>%
  mutate(time=dmy(paste("01", month, year, sep="-"))) %>%
  filter(!is.na(`No of Bedrooms`)) %>%
  filter(`No of Bedrooms`<6, `No of Bedrooms`>0) %>%
  ggplot(aes(x=time, y=rent)) +
    geom_line(aes(group=Postcode), alpha=0.5) +
    facet_wrap(~`No of Bedrooms`, ncol = 3) +
    ylab("Weekly rent") + ylim(c(0, 1000)) +
    geom_smooth(se=FALSE)
```

---

```{r}
rentals %>% 
  mutate(month=month(`Bond Lodgement date (DD/MM/YYYY)`), 
         year=year(`Bond Lodgement date (DD/MM/YYYY)`)) %>%
  group_by(Postcode, month, year, `No of Bedrooms`) %>%
  summarise(rent=mean(`Weekly Rent`, na.rm=TRUE)) %>%
  mutate(time=dmy(paste("01", month, year, sep="-"))) %>%
  filter(!is.na(`No of Bedrooms`)) %>%
  filter(`No of Bedrooms`<6, `No of Bedrooms`>0) %>%
  ggplot(aes(x=time, y=rent)) +
    geom_line(aes(group=Postcode), alpha=0.5) +
    facet_wrap(~`No of Bedrooms`, ncol = 3) +
    ylab("Weekly rent") + ylim(c(0, 1000)) +
    geom_smooth(se=FALSE)
```

---
# Googlesheets

- Google sheets are effectively excel spreadsheets
- We can read these directly also
- More efficient than download and read in

```{r echo=TRUE, eval=FALSE}
library(readxl) # Read from moodle excel sheet
class <- read_xlsx("ETC1010 - S2 2017 Grades.xlsx")

library(googlesheets) # Now get lab scores
gs_ls()
Waiting for authentication in browser...
Press Esc/Ctrl + C to abort
lss <- gs_title("ETC1010")
labs <- gs_read(lss, col_types=c("ccccddc"))

lab_scores <- full_join(class, labs[,c(1,5,6,7)],
                          by=c("ID number"="ID number")) %>%
  filter(!is.na(Surname)) %>%
  rename("Lab 1"="Lab 1(Out of 10)") %>%
  replace_na(list(`Lab 1`=0))
```

---
class: inverse middle 
# Share and share alike

<a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.

