---
title: "Model Building and Fitting"
author: "David T. Frazier"
date: "30/08/2017"
output:
  xaringan::moon_reader:
    css: ["default", "myremark.css"]
    self_contained: false
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false

---


```{r setup, include=FALSE}
library(knitr)
opts_chunk$set(fig.align = 'center',echo=FALSE)
library(tidyverse)
library(ggplot2)
library(readr)
library(readxl)
library(modelr)
library(plotly)
library(lubridate)

```



# Overview
- Modeling Basics with R
- Building Models: Linearity
- How to fit models? Optimization
    - Nonlinear optimization
- Linear Optimization
    - Basics
    - Examples

---
# Modeling Basics in R

---
# But Why Models?
- EDA allows us to understand that variables are related, but **not necessarily how** 
- Models allow us to understand
    - how variables are related, strength of relationship, direction of relationship
- More than correlation and direction 
    - Correlation can be [spurrious](www.tylervigen.com/spurious-correlations)
    - ![Decieving](/Users/frazdt/Dropbox/ETC1010/S2_2017_Notes/Picture1.png)

---
# But Why Models? 
- ''The goal of a model is to provide a simple low-dimensional summary of a dataset.''
- A **family of models** express a relationship between different variables.
- Allow us to predict outcomes of interest, given other variables!
- Prediction is critical in many fields


---
# Model Familieis
- Model Family describes a relationship between an outcome $(Y)$ and an input, covariate, pre-determined variable $(X)$.
- EX: $Y=b_0 + b_1 X +b_2 X^2+...+b_p X^p$
    - Class of polynomials in $X$
    - If $b_2=b_3=...=b_p=0$, linear relationship
- EX: $F=m\cdot a$

---
# Example
- Alumni Giving
- scatter plot can inform us about model structure
```{r fig.width=6, fig.height=5}
# Load Alumni Giving data file
Giving<- read.csv("AlumniGiving.csv")
p<-ggplot(Giving, aes(x=Giving$Student.Faculty.Ratio,y=Giving$Alumni.Giving.Rate)) + geom_point()

 p+geom_smooth(method='lm',formula=y~x)
```
---
# Example
```{r fig.width=6, fig.height=5}

# Load New_Auto data file
load("Auto_data")
p<-ggplot(New_Auto, aes(x=New_Auto$horsepower, y=New_Auto$mpg)) + geom_point()
 p+geom_smooth(method='lm',formula=y~x)

```

---
# Stat with a Family
- Linear models are always useful!
- How to find the best model?

---
# Linear Models
- $Y = b_0 + b_1 X$
- Find $b_0$ and $b_1$ that generate the **model** with the **smallest distance from the data**
- **Distance** between Observed $Y$ and $b_0 +b_1 X$
- **Smallest** over the sample $(y_i,x_i),i=1,...,n$

---
# Potential Distances
- Need a measure of distance between $y_i$ and $b_0+b_1 x_i$ (over $i=1,...,n$)
- What about $\sum_{i}\{y_i - b_0 -b_1 x_i\}^2$?
    - Just OLS!!!
```{r fig.width=6, fig.height=3.5}
 data<-Giving
 data$x<-Giving$Student.Faculty.Ratio
 data$y<-Giving$Alumni.Giving.Rate
model1 <- function(b, data) {
  b[1] + data$x * b[2]
}

measure_distance1 <- function(mod, data) {
  diff <- data$y - model1(mod, data)
  (sqrt(mean(diff^2 )))
}

sim1_dist <- function(b0, b1) {
  measure_distance1(c(b0, b1), data)
}


models <- tibble(
 b0 = seq(40, 65, length.out=50 ),
b1 = seq(-3, 0, length.out=50 )
)

models <- models %>% 
  mutate(dist = purrr::map2_dbl(b0,b1, sim1_dist))
# plot() model implied distances across x coordinate
# Shape of above objective function across a grid for $b_0$
v <- ggplot(models, aes(x=models$b1, y=models$dist))
v + geom_line()
```

---
# Other distances?
- What about $\sum_{i}|y_i - b_0 -b_1 x_i|$?
    - Called least absolute deviations.
  
```{r fig.width=6, fig.height=3.5}
measure_distance2 <- function(mod, data) {
  diff <- data$y - model1(mod, data)
  (mean(abs(diff )))
}

sim2_dist <- function(b1, b2) {
  measure_distance2(c(b1, b2), data)
}

models2 <- tibble(
 b0 = seq(0, 100, length.out=50 ),
b1 = seq(-10, 10, length.out=50 )
)

models2 <- models2 %>% 
  mutate(dist = purrr::map2_dbl(b0,b1, sim2_dist))
# plot() model implied distances across x coordinate
# Shape of above objective function across a grid for $b_0$
v <- ggplot(models2, aes(x=models2$b1, y=models2$dist))
v + geom_line()
```
---
# Other distances?
- What about $\sum_{i}(y_i - b_0 -b_1 x_i)^{3}$?
  
```{r fig.width=6, fig.height=3.5}
measure_distance2 <- function(mod, data) {
  diff <- data$y - model1(mod, data)
  (mean((diff )^(3)))
}

sim2_dist <- function(b1, b2) {
  measure_distance2(c(b1, b2), data)
}

models2 <- tibble(
 b0 = seq(0, 100, length.out=50 ),
b1 = seq(-10, 10, length.out=50 )
)

models2 <- models2 %>% 
  mutate(dist = purrr::map2_dbl(b0,b1, sim2_dist))
# plot() model implied distances across x coordinate
# Shape of above objective function across a grid for $b_0$
v <- ggplot(models2, aes(x=models2$b1, y=models2$dist))
v + geom_line()
```
---
# Other distances?
- What about $\sqrt{\sum_{i}(y_i - b_0 -b_1 x_i)^4}$?
  
```{r fig.width=6, fig.height=3.5}
measure_distance2 <- function(mod, data) {
  diff <- data$y - model1(mod, data)
  sqrt(mean((diff )^4))
}

sim2_dist <- function(b1, b2) {
  measure_distance2(c(b1, b2), data)
}

models2 <- tibble(
 b0 = seq(0, 100, length.out=50 ),
b1 = seq(-10, 10, length.out=50 )
)

models2 <- models2 %>% 
  mutate(dist = purrr::map2_dbl(b0,b1, sim2_dist))
# plot() model implied distances across x coordinate
# Shape of above objective function across a grid for $b_0$
v <- ggplot(models2, aes(x=models2$b1, y=models2$dist))
v + geom_line()
```

---
# Different distances
- Different distances measure different things
    - $d\{y_i,b_0+b_1x_i\}=y-b_0-b_1 x,$
    - $d\{y_i,b_0+b_1x_i\}=|y-b_0-b_1 x|,$ 
    - $d\{y_i,b_0+b_1x_i\}=(y-b_0-b_1 x)^2$ 
- $f(b_0,b_1)=\sum_{i}d\{y_i,b_0+b_1x_i\}$ is called **the objective function**
- Takes in 
    - data: $(y_i,x_i)$
    - parameters: $b_0,b_1$
- Outputs
    - measure of distance between $y_{i}$ and $b_0+b_{1}x_{i}$ over sample
---
# What was the goal again?
- Find the "best" model in the linear family...
- I.E., find $b_0,b_1$ that "generate the **model** with the **smallest distance from the data**"
- Translation: Find $b_0,b_1$ that makes $f(b_0,b_1)$ **small**.

---
# Optimization
- This is called Optimization.
- Solution will depend on $f(b_0,b_1)$
- How to find $b_0,b_1$?

---
# Optimization
- $min_{b_0,b_1}\sum_{i}d\{y_i,b_0+b_1x_i\}$
    - Ex: ${\sum_{i}\{y_i-b_0-b_1x_i\}^2}$
        - Ordinary least squares
    - Ex: $\sum_{i}|y_i-b_0-b_1x_i|$
        - Last absolute deviations
- How can we find the minimum?

---
# Method 1: Grid Search
- Construct grid of values $b_0,b_1$.
- Evaluate $f(b_0,b_1)$.
- Find $b_0,b_1$ that make $f(b_0,b_1)$ smallest.

---
# Grid Search con't.
- Alumni giving dataset  
```{r, echo=TRUE}
model1 <- function(b, data) {
  b[1] + data$x * b[2]}

measure_distance1 <- function(mod, data) {
  diff <- data$y - model1(mod, data)
  (sqrt(mean(diff^2 )))}

sim1_dist <- function(b0, b1) {
  measure_distance1(c(b0, b1), data)}

grid <- expand.grid(
  b0 = seq(40, 65, length = 100),
  b1 = seq(-3, 0, length = 100)
  ) %>% 
  mutate(dist = purrr::map2_dbl(b0, b1, sim1_dist))
c(grid$b0[grid$dist==min(grid$dist)],grid$b1[grid$dist==min(grid$dist)])
```
---
# Grid Search con't.
- Built in function to do OLS in `R`  
```{r, echo=TRUE}
fit1<- lm(y~x,data)
fit1$coefficients

```
- More on this later, but check out `?lm` for now...
---
# Grid Search con't.
- Alumni giving dataset  
```{r, echo=TRUE}
model1 <- function(b, data) {
  b[1] + data$x * b[2]}

measure_distance1 <- function(mod, data) {
  diff <- data$y - model1(mod, data)
  ((mean(abs(diff) )))}

sim1_dist <- function(b0, b1) {
  measure_distance1(c(b0, b1), data)}

grid_o <- expand.grid(
  b0 = seq(40, 65, length = 100),
  b1 = seq(-3, 0, length = 100)
  ) %>% 
  mutate(dist = purrr::map2_dbl(b0, b1, sim1_dist))
c(grid_o$b0[grid_o$dist==min(grid_o$dist)],grid_o$b1[grid_o$dist==min(grid_o$dist)])
```

---
# General optimization
- Grid search not very useful in higher dimension
- How to set the grid?
- Need general approach

---
# `optim` function in R...
- Allows you to optimize user supplied functions
- Works with non-differentiable functions
- Syntax: `optim(init, f, method="NM")`
    - init: initial values for the optimizer
    - f: objective function
    - method: different optimization routines
    - More on this later

---
#`optim` Example
- Example: Alumni Giving
```{r, echo=TRUE}
measure_distance2 <- function(mod, data) {
  diff <- data$y - model1(mod, data)
  sqrt((mean((diff )^2)))
}
measure_distance3 <- function(mod, data) {
  diff <- data$y - model1(mod, data)
  (mean(abs(diff )))
}
best2 <- optim(c(0, 0), measure_distance2, data = data)
best2$par
best3 <- optim(c(0, 0), measure_distance3, data = data)
best3$par
```

---
#`optim` in R
- Example: Alumni Giving
```{r, echo=TRUE}
measure_distance2 <- function(mod, data) {
  diff <- data$y - model1(mod, data)
  ((mean((diff )^(3/2))))
}

best2 <- optim(c(0, 0), measure_distance2, data = data)
best2$par
```
